###############################################################################
# SCRIPT NAME: Beta Diversity Estimation
#
# DESCRIPTION:
#   This script calculates taxonomic and functional beta diversity for datasets
#   included in the study. It uses:
#     - `BAT` package for taxonomic beta diversity.
#     - `hypervolume` package for functional beta diversity, modeling multidimensional
#       trait spaces and performing pairwise comparisons.
#   The results are saved as structured output files for downstream analyses.
#
# USAGE:
#   - It must be run **after** the `1_get_functional_dissimilarities.R` script, as
#     the output files from that script (`betadiv_input`) are used here.
#   - The script can be executed on an HPC cluster using SLURM or manually for
#     individual datasets. To run for a specific dataset, uncomment the relevant lines.
#
# INPUTS:
#   - Pre-processed functional dissimilarity files generated by `get_functional_dissimilarities.R`
#     (located in `betadiv_input/`).
#
# OUTPUTS:
#   - Beta diversity results (Taxonomic and Functional) saved in `betadiv_output/`
#     with the naming format: `{dataset_name}_beta_Output.rds`
#
# DEPENDENCIES:
#   - `get_functional_dissimilarities.R`: must be run beforehand to generate
#     the input files for this script.
#
# AUTHOR: Caio Graco-Roza
# LAST UPDATED: 2024-11-20
#
# NOTES:
#   - Ensure required libraries (`BAT`, `hypervolume`, etc.) are installed.
#   - The script uses parallel processing to speed up computation, leveraging
#     available cores on an HPC.
#   - Functional beta diversity calculations require sufficient species trait
#     data; sites with missing or insufficient traits will be skipped.
###############################################################################

# Packages .............................................................................................................
if(!require("pacman")) {install.packages("pacman")}

pacman::p_load(
  BAT #make taxonomic beta diversity
  ,hypervolume #make functional beta diversity
  ,tidyverse #manage data
  ,magrittr #use set names
  ,glue #create strings
  ,readxl #read rds files
  ,future #set up cores available
  ,doSNOW # make parallel procedure
  )

#combine the results from beta diversite into organized lists 
appendList <- function (x, val) {
  stopifnot(is.list(x), is.list(val))
  xnames <- names(x)
  for (v in names(val)) {
    x[[v]] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
      appendList(x[[v]], val[[v]])
    else c(x[[v]], val[[v]])
  }
  x
}

#' This script is designed to:
#' - estimate taxonomic and functional beta diversity by applying abundance weights to species.

#Only for HPC cluster (Doesn't affect anything in local machines) ---------------------------------------------------
# grab the array id value from the environment variable passed from sbatch
slurm_arrayid <- Sys.getenv('SLURM_ARRAY_TASK_ID')
# coerce the value to an integer
ii <- as.numeric(slurm_arrayid)
#' =================================================================================================================

#' -----------------------------------------------------------------------------------------------------------------
# @ run analysis ######
#' -----------------------------------------------------------------------------------------------------------------
#' Reference: 

files <- tools::file_path_sans_ext(list.files("betadiv_input")) #get a vector with dataset names

focal_dataset <- gsub("_beta_Input","",files[ii]) #chose one dataset 
write(focal_dataset, stderr())
species_diff <- glue::glue("betadiv_input/{focal_dataset}_beta_Input.rds") %>%  read_rds() #read the dataset pre processed file

comm <- species_diff %>%  pluck("comm") #extract the community data
traits <- species_diff %>%  pluck("trait_syndrome") #extract the synthetic traits (PCoA Axes)

#make sure the community only has species with trait values. 
comm <- comm %>%  select(any_of(rownames(traits)))

#Estimate Taxonomic Beta diversity ---------------------------------------------------------------------------------
write(" -------------------------- Estimate taxonomic beta div", stderr())
TBeta <- BAT::beta(comm, abund = TRUE, func = "sorensen") 

# Estimate Functional Beta diversity -------------------------------------------------------------------------------
write(" -------------------------- Estimate functional alpha  div", stderr())
cores<- future::availableCores() #get number of available cores (I use all because the HPC allows me to, usually beter cores/2)
cl <- makeSOCKcluster(cores)

registerDoSNOW(cl)

alpha.FD <- foreach(
  i = 1:nrow(comm),
  .combine = hypervolume::hypervolume_join,
  .multicombine = TRUE,
  .errorhandling = 'remove'
) %dopar% {
  .libPaths(c("/projappl/project_2004932/project_rpackages_4.0.5", .libPaths()))
  subset <- traits[names(comm[i, which(comm[i,] > 0)]), 1:3] 
  abun <- comm[i, which(comm[i,] > 0)]
  hv <- hypervolume::hypervolume_gaussian(
    data = subset #keep only species that are present in the community
    ,verbose=FALSE
    ,name = rownames(comm)[i] #site name
    ,weight = as.numeric(abun/sum(abun))
    #,kde.bandwidth = estimate_bandwidth(subset,method="silverman-1d")
  )
}
stopCluster(cl)

write(" -------------------------- Estimate functional beta div", stderr())
#get number of site where beta diversity did not fail 
alpha_n<-length(alpha.FD@HVList)

#get name of these sites
name_sites<-sapply(seq_along(alpha.FD@HVList), function(i) alpha.FD@HVList[[i]]@Name)

#start new parallel
cl <- makeSOCKcluster(cores)
registerDoSNOW(cl)

#run nested loop for pairwise comparison
pairwise_beta <-  foreach(i = 1:alpha_n,
                          .combine = appendList) %:%
  foreach(j = i:alpha_n, .combine = appendList) %dopar% {
  .libPaths(c("/projappl/project_2004932/project_rpackages_4.0.5", .libPaths()))
    hyperSet <- hypervolume::hypervolume_set(alpha.FD@HVList[[i]]
                                            ,alpha.FD@HVList[[j]]
                                            ,check.memory = FALSE
                                            ,verbose = FALSE
                                            ,num.points.max=5^(3+sqrt(3))) #number of points was reduced by a half the default scalar
    
    union <- hyperSet[[4]]@Volume
    unique1 <- hyperSet[[5]]@Volume
    unique2 <- hyperSet[[6]]@Volume
    
    #apply sorensen calculation of beta diversity
    union <- 2 * union - unique1 - unique2
    Btotal <- (unique1 + unique2) / union
    Brepl <- 2 * min(unique1, unique2) / union
    Brich <- abs(unique1 - unique2) / union
    output <- list(Btotal = Btotal,
                   Brepl = Brepl,
                   Brich = Brich)
    return(output)
  }
stopCluster(cl)

#Assemble beta objects into distance matrices
output_beta<-lapply(1:3, function(x) matrix(NA,alpha_n,alpha_n))
names(output_beta) <- c("Btotal","Brepl","Brich")

output_beta$Btotal[lower.tri(output_beta$Btotal,diag=TRUE)] <-round(pairwise_beta$Btotal,3) #fill up the lower triangle of the matrix
output_beta$Brepl [lower.tri(output_beta$Btotal,diag=TRUE)] <- round(pairwise_beta$Brich,3) #fill up the lower triangle of the matrix
output_beta$Brich [lower.tri(output_beta$Btotal,diag=TRUE)] <- round(pairwise_beta$Brepl,3) #fill up the lower triangle of the matrix
FBeta <- lapply(output_beta, as.dist) #conver matrices into distance objects 
FBeta <- lapply(FBeta, function(x) set_names(x, name_sites)) # set site names for the distance matrices



# Save resutls  ---------------------------------------------------------------------------------------------------


betadiv <- list(Taxonomic = TBeta,
                Functional = FBeta)

saveRDS(object = betadiv, file = glue::glue("betadiv_output/{focal_dataset}_beta_Output.rds"))
